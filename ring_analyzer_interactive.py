import numpy as np
import sys
import os

class Molecule:
    def __init__(self, filename):
        """Initialize molecule from an XYZ file."""
        self.atoms = []
        self.coords = []
        self.read_xyz(filename)

    def read_xyz(self, filename):
        """Read XYZ file into atoms and coordinates."""
        try:
            with open(filename, 'r') as f:
                lines = f.readlines()
                n_atoms = int(lines[0].strip())
                for line in lines[2:2 + n_atoms]:
                    parts = line.strip().split()
                    if len(parts) < 4:
                        raise ValueError("Invalid XYZ format")
                    self.atoms.append(parts[0])
                    self.coords.append(list(map(float, parts[1:4])))
                self.coords = np.array(self.coords)
        except FileNotFoundError:
            print(f"Error: File '{filename}' not found.")
            sys.exit(1)
        except ValueError as e:
            print(f"Error: {e}")
            sys.exit(1)

    def get_centroid(self, ring_atoms):
        """Calculate centroid of specified ring atoms (1-based indices)."""
        if not all(1 <= i <= len(self.coords) for i in ring_atoms):
            raise ValueError("Atom indices out of range")
        ring_coords = self.coords[np.array(ring_atoms) - 1]  # Convert to 0-based
        return np.mean(ring_coords, axis=0)

    def add_atom(self, atom_symbol, position):
        """Add a new atom at the specified position."""
        self.atoms.append(atom_symbol)
        self.coords = np.vstack([self.coords, position])

    def distance(self, idx1, idx2):
        """Calculate distance between two atoms (1-based indices)."""
        return np.linalg.norm(self.coords[idx1 - 1] - self.coords[idx2 - 1])

    def angle(self, idx1, idx2, idx3):
        """Calculate angle (degrees) between three atoms (1-based indices)."""
        v1 = self.coords[idx1 - 1] - self.coords[idx2 - 1]  # Vector from idx2 to idx1
        v2 = self.coords[idx3 - 1] - self.coords[idx2 - 1]  # Vector from idx2 to idx3
        cos_theta = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
        cos_theta = np.clip(cos_theta, -1.0, 1.0)  # Clamp to avoid floating-point errors
        return np.degrees(np.arccos(cos_theta))

    def dihedral(self, idx1, idx2, idx3, idx4):
        """Calculate dihedral angle (degrees) between four atoms (1-based indices)."""
        p0 = self.coords[idx1 - 1]
        p1 = self.coords[idx2 - 1]
        p2 = self.coords[idx3 - 1]
        p3 = self.coords[idx4 - 1]

        # Vectors for the three bonds
        b0 = p1 - p0
        b1 = p2 - p1
        b2 = p3 - p2

        # Normals to the planes
        n1 = np.cross(b0, b1)
        n2 = np.cross(b1, b2)

        # Normalize normals
        n1 = n1 / np.linalg.norm(n1)
        n2 = n2 / np.linalg.norm(n2)

        # Calculate dihedral angle
        cos_theta = np.dot(n1, n2)
        cos_theta = np.clip(cos_theta, -1.0, 1.0)  # Clamp to avoid floating-point errors
        angle = np.degrees(np.arccos(cos_theta))

        # Determine the sign of the dihedral angle
        if np.dot(b1, np.cross(n1, n2)) < 0:
            angle = -angle
        return angle

    def write_xyz(self, filename):
        """Write molecule to an XYZ file."""
        with open(filename, 'w') as f:
            f.write(f"{len(self.atoms)}\n")
            f.write("Generated by ring_analyzer.py\n")
            for atom, coord in zip(self.atoms, self.coords):
                f.write(f"{atom} {coord[0]:.6f} {coord[1]:.6f} {coord[2]:.6f}\n")

def get_atom_indices(prompt, expected_count=None):
    """Get atom indices from user input, ensuring they are valid integers."""
    while True:
        try:
            indices = list(map(int, input(prompt).strip().split()))
            if expected_count and len(indices) not in expected_count:
                print(f"Error: Expected {expected_count} atom indices.")
                continue
            if not all(i > 0 for i in indices):
                print("Error: Atom indices must be positive integers.")
                continue
            return indices
        except ValueError:
            print("Error: Please enter valid integer indices separated by spaces.")

def main():
    print("Metallocene and Inverse Sandwich Analyzer")
    print("=======================================")
    print("This script analyzes molecular structures by adding dummy atoms to ring centroids,")
    print("calculating distances, angles, and for 3-ring cases, middle ring bond distances,")
    print("dihedral angles, and metal-metal distance.")
    print("CAUTION: For 3-ring cases, middle ring (ring2) atom indices must be provided in")
    print("sequential order as they appear consecutively around the ring")
    print("(e.g., for a benzene ring: 1 2 3 4 5 6) for accurate calculations.")
    print("=======================================")

    # Get input file
    xyz_file = input("Enter the input XYZ file name: ").strip()
    # Generate output file name by appending '_analyzed'
    base, ext = os.path.splitext(xyz_file)
    output_file = f"{base}_analyzed{ext}"

    # Get number of rings
    while True:
        try:
            num_rings = int(input("Enter the number of rings (2 or 3): ").strip())
            if num_rings not in [2, 3]:
                print("Error: Number of rings must be 2 or 3.")
                continue
            break
        except ValueError:
            print("Error: Please enter a valid integer (2 or 3).")

    # Load molecule
    mol = Molecule(xyz_file)

    # Collect ring data
    rings = {}
    rings["ring1"] = get_atom_indices("Enter atom indices for ring 1 (5 or 6 atoms, space-separated): ", [5, 6])
    rings["ring2"] = get_atom_indices("Enter atom indices for ring 2 (5 or 6 atoms, space-separated): ", [5, 6])
    if num_rings == 3:
        rings["ring3"] = get_atom_indices("Enter atom indices for ring 3 (5 or 6 atoms, space-separated): ", [5, 6])

    # Validate ring sizes
    for label, ring in rings.items():
        if len(ring) not in [5, 6]:
            print(f"Error: {label} must have 5 or 6 atoms.")
            sys.exit(1)
        print(f"{label} detected as a {len(ring)}-membered ring.")

    # Get metal indices
    metal1_idx = get_atom_indices("Enter atom index for metal 1: ", [1])[0]
    metal2_idx = None
    if num_rings == 3:
        metal2_idx = get_atom_indices("Enter atom index for metal 2: ", [1])[0]

    # Calculate centroids and add dummy atoms
    centroids = {}
    dummy_indices = {}
    for i, (label, ring_atoms) in enumerate(rings.items(), 1):
        centroid = mol.get_centroid(ring_atoms)
        centroids[f"com{i}"] = centroid
        print(f"Ring {i} centroid: {centroid[0]:.4f}, {centroid[1]:.4f}, {centroid[2]:.4f}")
        mol.add_atom("X", centroid)
        dummy_indices[f"com{i}"] = len(mol.atoms)  # 1-based index

    print(f"Added {len(rings)} dummy atoms ('X') at ring centroids.")

    # Calculate distances
    metal1_symbol = mol.atoms[metal1_idx - 1]
    print(f"Distance from {metal1_symbol} to Ring 1 centroid: {mol.distance(metal1_idx, dummy_indices['com1']):.4f} Å")
    print(f"Distance from {metal1_symbol} to Ring 2 centroid: {mol.distance(metal1_idx, dummy_indices['com2']):.4f} Å")
    
    if num_rings == 3:
        metal2_symbol = mol.atoms[metal2_idx - 1]
        print(f"Distance from {metal2_symbol} to Ring 2 centroid: {mol.distance(metal2_idx, dummy_indices['com2']):.4f} Å")
        print(f"Distance from {metal2_symbol} to Ring 3 centroid: {mol.distance(metal2_idx, dummy_indices['com3']):.4f} Å")
        print(f"Distance from {metal1_symbol} to {metal2_symbol}: {mol.distance(metal1_idx, metal2_idx):.4f} Å")

        # Calculate bond distances for middle ring (ring2)
        print("\nBond distances in middle ring (ring2):")
        ring2_atoms = rings["ring2"]
        for i in range(len(ring2_atoms)):
            atom1 = ring2_atoms[i]
            atom2 = ring2_atoms[(i + 1) % len(ring2_atoms)]  # Cyclic: connects last to first
            atom1_symbol = mol.atoms[atom1 - 1]
            atom2_symbol = mol.atoms[atom2 - 1]
            dist = mol.distance(atom1, atom2)
            print(f"Distance {atom1_symbol}{atom1}--{atom2_symbol}{atom2}: {dist:.4f} Å")

        # Calculate dihedral angles for middle ring (ring2)
        print("\nDihedral angles in middle ring (ring2):")
        for i in range(len(ring2_atoms)):
            idx1 = ring2_atoms[i]
            idx2 = ring2_atoms[(i + 1) % len(ring2_atoms)]
            idx3 = ring2_atoms[(i + 2) % len(ring2_atoms)]
            idx4 = ring2_atoms[(i + 3) % len(ring2_atoms)]
            atom1_symbol = mol.atoms[idx1 - 1]
            atom2_symbol = mol.atoms[idx2 - 1]
            atom3_symbol = mol.atoms[idx3 - 1]
            atom4_symbol = mol.atoms[idx4 - 1]
            dihedral = mol.dihedral(idx1, idx2, idx3, idx4)
            print(f"Dihedral {atom1_symbol}{idx1}-{atom2_symbol}{idx2}-{atom3_symbol}{idx3}-{atom4_symbol}{idx4}: {dihedral:.2f} degrees")

    # Calculate angles
    if num_rings == 2:
        angle = mol.angle(dummy_indices["com1"], metal1_idx, dummy_indices["com2"])
        print(f"Angle CoM1-{metal1_symbol}-CoM2: {angle:.2f} degrees")
    else:  # 3 rings
        angle1 = mol.angle(dummy_indices["com1"], metal1_idx, dummy_indices["com2"])
        angle2 = mol.angle(dummy_indices["com1"], dummy_indices["com2"], dummy_indices["com3"])
        angle3 = mol.angle(dummy_indices["com2"], metal2_idx, dummy_indices["com3"])
        angle4 = mol.angle(metal1_idx, dummy_indices["com2"], metal2_idx)
        print(f"Angle CoM1-{metal1_symbol}-CoM2: {angle1:.2f} degrees")
        print(f"Angle CoM1-CoM2-CoM3: {angle2:.2f} degrees")
        print(f"Angle CoM2-{metal2_symbol}-CoM3: {angle3:.2f} degrees")
        print(f"Angle {metal1_symbol}-CoM2-{metal2_symbol}: {angle4:.2f} degrees")

    # Save modified structure
    mol.write_xyz(output_file)
    print(f"Modified structure with {len(rings)} dummy atoms saved to '{output_file}'.")

if __name__ == "__main__":
    main()
